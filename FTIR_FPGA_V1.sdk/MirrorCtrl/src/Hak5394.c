/*
 * Hak5394.c
 *
 *  Created on: 2019年6月14日
 *      Author: hpy
 */
#include "Hak5394.h"
#include "xparameters.h"
#include "xil_io.h"
#include "sleep.h"

/*
 int ak5394_m1[AK_5394_DATA_BUF_LEN] __attribute__((section(".ak5394M1Section")));//
 int ak5394_m2[AK_5394_DATA_BUF_LEN] __attribute__((section(".ak5394M2Section")));//
 //分配DDR中对应AD数据时间的内存地址给数组
 u32 ak5394_t1[AK_5394_DATA_BUF_LEN] __attribute__((section(".ak5394T1Section")));//
 u32 ak5394_t2[AK_5394_DATA_BUF_LEN] __attribute__((section(".ak5394T2Section")));//
 */
int *ak5394_m1 = (int*) AK_5394_DATA1_BASE_ADDR; //
int *ak5394_m2 = (int*) AK_5394_DATA2_BASE_ADDR; //
//分配DDR中对应AD数据时间的内存地址给数组
u32 *ak5394_t1 = (u32 *) AK_5394_TIME1_BASE_ADDR; //
u32 *ak5394_t2 = (u32 *) AK_5394_TIME2_BASE_ADDR; //
u32 *ak5394_laser_t1 = (u32 *) AK_5394_LASER_PULSE_TIME1_BASE_ADDR; //激光脉冲时间标刻1指针数组
u32 *ak5394_laser_t2 = (u32 *) AK_5394_LASER_PULSE_TIME2_BASE_ADDR; //激光脉冲时间标刻2指针数组

u32 ak_option = 0U;
/***********************************************************************************************/
/**50MHz时钟时
 * 初始化AK5394，设为默认值,软件采集
 * 默认值：AD数据int型  ,ak5394的ZCAL引脚电平
 * LF398电压锁存后等待AD转换的时间 默认12us，所以默认waiteTime = 12 * 50 =600
 * 使用LF398锁存后，只在ready信号有效时更新AD数据,,默认为0，接收数据后就立马更新AD读数
 * LF398触发信号的高电平时间为 [27:0]/10 us，如设置为10us，则[277:0]=10*50=500,用于触发LF398工作
 *
 ***********************************************************************************************/
void Hak5394_init(void) {
	AK5394_LF398_mWriteReg(XPAR_AK5394_LF398_0_S00_AXI_BASEADDR,
			AK5394_LF398_S00_AXI_SLV_REG0_OFFSET, (u32 )0); //设置默认值
}
/***********************************************************************************************/
/**
 * 初始化AK5394，设为默认值,FPGA采集
 * 默认值：AD数据int型  ,ak5394的ZCAL引脚电平
 * LF398电压锁存后等待AD转换的时间 默认12us，所以默认waiteTime = 12 * f
 * 使用LF398锁存后，只在ready信号有效时更新AD数据,,默认为0，接收数据后就立马更新AD读数
 * LF398触发信号的高电平时间为 [27:0]/10 us，如设置为10us，则[277:0]=10*50=500,用于触发LF398工作
 *
 ***********************************************************************************************/
void Hak5394_PL_init() {
	Hak5394_init();
	Hak5394_WriteReg((u32) 9, AK_5394_DATA_BUF_LEN); //设置AD采样点数  204800，该参数决定了硬件在哪一片DDR中进行数据写入
	Hak5394_WriteReg((u32) 12, (u32) 2); //开启AD通道2复用为AD数据硬件实际采集量，在读数据中断时通过2通道读取
	Hak5394_WriteReg((u32) 11, (u32) 1); //设置AK5394模式  0：连续采集 1：定时采集 2：触发采集 3：自测模式
	Hak5394_WriteReg((u32) 5, 15000u); //设置AK5394定时采集的时间   150MHz计数15000次（10us采集一次）
	Hak5394_Reuse_ch1(1); //开启通道1为激光脉冲时间数据量
	Hak5394_SetTimerFeq(15U); //设置计时器基础时钟频率 150MHz计数15次，10MHz（时标数据的基础时钟）
	//Hak5394_SetOption(AK_ENABLE_PL_FILTER,0);//开启PL 滤波
	//Hak5394_WriteReg((u32)14,(u32) 6000);//设置硬件数据生成间隔
	Hak5394_WriteReg((u32) 13, (u32) 1);	//开启硬件采集数据
}
/*************************************************************************************************************************************/
/**
 * 写控制寄存器和控制数据
 * 参数1：cmd 范围0-15  ，必须是无符号整型
 * 参数2：data范围+2^28
 *
 //写指令全在寄存器0
 //[31:28] = 0:默认参数 默认AD数据int型，LF398触发脉冲为10us，MCLK需要设置Fclk = 50MHz / 分频值(MCLK默认没有时钟)
 //[31:28] = 1:设置LF398触发信号的高电平时间为 [27:0]/50 us，如设置为10us，则[277:0]=10*50=500,用于触发LF398工作

 //[31:28] = 2:开启AD高8位数据的有用性，1:有用，0：无用。31位为LF398触发脉冲，30位为激光脉冲信号，29：动镜方向信号
 //[31:28] = 3:设置ak5394复位引脚电平，[0]的值为电平值
 //[31:28] = 4:设置ak5394的ZCAL引脚电平，[0]的值为电平值
 //[31:28] = 5:设置ak5394的MCLK的时钟，[27:0]是对50MHz时钟的分频数
 //[31:28] = 6:设置LF398电压锁存后等待AD转换的时间 默认12us，所以默认waiteTime = 12 * 50 =600
 //[31:28] = 7:使用LF398锁存后，只在ready信号有效时更新AD数据,,默认为0，接收数据后就立马更新AD读数
 //[31:28] = 8:设置ak5394的ready信号高电平持续时间，[27:0]/50 us   如设置为10us，则[277:0]=10*50=500
 //使用时首先调用默认参数设置，然后调用设置MCLK时钟的指令即可，接qsw的AD板时只需要调用默认设置指令就可，AD读取的数使用32位的int型保存
 ****************************************************************************************************************************************/
void Hak5394_WriteReg(u32 cmd, u32 data) {
	u32 reg0 = ((cmd << 28) & 0xf0000000) | (data & 0x0fffffff);
	AK5394_LF398_mWriteReg(XPAR_AK5394_LF398_0_S00_AXI_BASEADDR,
			AK5394_LF398_S00_AXI_SLV_REG0_OFFSET, reg0);
	usleep(10);
}
/********************************************************************
 * 设置ak5394计时器的计时器频率
 * 输入的参数为分频数
 * 0:关闭时钟
 * 1:不分频
 * N：N分频
 *******************************************************************/
void Hak5394_SetTimerFeq(u32 f) {
	Hak5394_WriteReg(10U, f);
}
/**********************************************************************
 * 设置定是采集的定时时间，在则测模式下，该值用于模拟激光脉冲信号
 *********************************************************************/
void Hak5394_SetGetDataInterval(u32 in) {
	Hak5394_WriteReg(5U, in);
}
/********************************************************************
 * 设置bit控制为参数
 * option:控制参数
 * sw：写入模式  0：直接写入新的option    1：在之前的基础上写入option
 ********************************************************************/
void Hak5394_SetOption(u32 option, int sw)	//设置硬件参数 bit设置
{
	if (sw != 0) {
		ak_option |= option;
	} else {
		ak_option = option;
	}
	Hak5394_WriteReg(7U, ak_option);
}
/******************************************************************************************/
/**
 * 当AD设置为整型数据时候，直接用该函数读取数据
 * 参数1：ch1表示通道，1：左通道   2：右通道
 * 设计中左通道数据有效
 *******************************************************************************************/
int Hak5394_GetData(u8 ch) {
	int d = 0;
	if (ch == 2) {
		d = AK5394_LF398_mReadReg(XPAR_AK5394_LF398_0_S00_AXI_BASEADDR,
				AK5394_LF398_S00_AXI_SLV_REG2_OFFSET);
	} else {
		d = AK5394_LF398_mReadReg(XPAR_AK5394_LF398_0_S00_AXI_BASEADDR,
				AK5394_LF398_S00_AXI_SLV_REG1_OFFSET);
	}
	return d;
}
/********************************************************************************/
/**
 * 获取AK5394各信号的状态
 *
 * [3:0] = [FPGA_AD_SCLK,FPGA_LOGIC_LF398,FPGA_LASER_PULSE,FPGA_DongJ_DIR]
 * [7:4] = [FPGA_AD_MCLK,FPGA_AD_FSYNC,FPGA_AD_SDATA,FPGA_AD_LRCK]
 * [11:8] = [isCloseAD,isOpen_AD_H8,FPGA_AD_RSTn,FPGA_AD_ZCAL]
* [29] = [inte]
 * [31] = [ready]:AD锁存转化后的数据稳定信号，高电平有效
 ********************************************************************************/
u32 Hak5394_GetStatus(void) {
	u32 ret = 0;
	ret = AK5394_LF398_mReadReg(XPAR_AK5394_LF398_0_S00_AXI_BASEADDR,
			AK5394_LF398_S00_AXI_SLV_REG3_OFFSET);
	return ret;
}
/******************************************************************************************/
/**
 * 设置硬件采集数据的缓存数据量大小
 * 参数1：设置的大小，范围为1-2^27(前提是DDR空间够用，DDR的可用空间至少满足>c(size*2)),针对采集AD
 * 数据，默认硬件使用8192*2的缓冲区
 *******************************************************************************************/
void Hak5394_SetDDRSize(u32 size) {
	Hak5394_WriteReg((u32) 9, size);
}

/******************************************************************************************/
/**
 * 开启硬件AD数据采集
 * 针对采集数据为8192个点，使用A9处理器的L2，刷新一次cache用时为30us，使用10khz进行触发，采集满一
 * 次数据用时为 8192*100 us = 819ms，接近于1s，因此有足够的时间进行数据传输，因此只需要在硬件采集
 * 完成的中断信号中进行数据缓存更新，尽量不要再其中处理其他数据
 *******************************************************************************************/
void Hak5394_StartGetData(void) {
	Hak5394_WriteReg(13U, 1U);
}
/*******************************************************************************************
 * 设置时间寄存器数据位宽
 * 输入参数：16U   32U，错误输入则默认设置为32位位宽
 ******************************************************************************************/
void Hak5394_SetTime_BitWide(u32 bitwide) {
	u32 op;
	if (bitwide == 16) {
		Hak5394_SetOption(AK_TIME_BIT_WIDE, 1);
	} else {
		op = ak_option & (~AK_TIME_BIT_WIDE);
		Hak5394_SetOption(op, 0);
	}

}
/*******************************************************************************************
 * 设置硬件滤波
 * 0:关闭硬件滤波，其他：开启硬件滤波
 ******************************************************************************************/
void Hak5394_Enable_PL_Filter(int set) {
	u32 op;
	if (set != 0) {
		Hak5394_SetOption(AK_ENABLE_PL_FILTER, 1);
	} else {
		op = ak_option & (~AK_ENABLE_PL_FILTER);
		Hak5394_SetOption(op, 0);
	}
}
/*******************************************************************************************
 * 设置数据通道1为激光脉冲时间数量通道
 * 0:关闭复用，其他：开启复用
 ******************************************************************************************/
void Hak5394_Reuse_ch1(int set) {
	u32 op;
	if (set != 0) {
		Hak5394_SetOption(AK_REUSE_REG1_LASER_TIME_NUM, 1);
	} else {
		op = ak_option & (~AK_REUSE_REG1_LASER_TIME_NUM);
		Hak5394_SetOption(op, 0);
	}
}

/*******************************************************************************************
 *开启LF398接受MCU设置逻辑电压
 * 0:关闭复用，其他：开启
 ******************************************************************************************/
void Hak5394_Enable_McuSetLf(int set) {
	u32 op;
	if (set != 0) {
		Hak5394_SetOption(AK_ENABLE_SET_LF398, 1);
	} else {
		op = ak_option & (~AK_ENABLE_SET_LF398);
		Hak5394_SetOption(op, 0);
	}
}
/*******************************************************************************************
 *设置LF398逻辑电压为高电平
 ******************************************************************************************/
void Hak5394_SetLfHigh(void) {

	Hak5394_SetOption(AK_SET_LF398_HIGH, 1);
}
/*******************************************************************************************
 *设置LF398逻辑电压为低电平
 ******************************************************************************************/
void Hak5394_SetLfLow(void) {
	u32 op;
	op = ak_option & (~AK_SET_LF398_HIGH);
	Hak5394_SetOption(op, 0);
}
/*******************************************************************************************
 *开启硬件采集终端信号同步AD数据 (AD数据完成就进行读取，无论时间信息是否完成写入DDR)
 * 0:关闭，其他：设置
 ******************************************************************************************/
void Hak5394_SetSysInt(u32 set) {
	u32 op;
	if (set != 0) {
		Hak5394_SetOption(AK_INT_SYS_AD_DATA, 1);
	} else {
		op = ak_option & (~AK_INT_SYS_AD_DATA);
		Hak5394_SetOption(op, 0);
	}
}
/*******************************************************************************************
 *设置丢失数据返回对象为激光脉冲时间顺序
 * 0:关闭，其他：设置
 ******************************************************************************************/
void Hak5394_SetMissDataCh(u32 set) {
	u32 op;
	if (set != 0) {
		Hak5394_SetOption(AK_MISS_DATA_AD_OR_LASER, 1);
	} else {
		op = ak_option & (~AK_MISS_DATA_AD_OR_LASER);
		Hak5394_SetOption(op, 0);
	}
}
/******************************************************************************************/
/**
 * 关闭硬件AD数据采集
 *******************************************************************************************/
void Hak5394_CloseGetData(void) {
	Hak5394_WriteReg((u32) 13, (u32) 0);
}

